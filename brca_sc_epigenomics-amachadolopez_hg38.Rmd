---
title: "sc-ChIPseq analysis of breast cancer - human cells"
author: "Alba Machado-Lopez"
date: "November 2022"
output: html_document
knit: (function(input_file, encoding) {
    out_dir <- 'docs';
    rmarkdown::render(input_file,
      encoding=encoding,
      output_file=file.path(dirname(input_file), out_dir, 'brca_sc_epigenomics_hg38.html'))})
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries

```{r, message=F}
library(dplyr)
library(stringr)
library(R.utils)
library(ggplot2)
library(ggpubr)
library(SingleCellExperiment)
library(Seurat)
library(purrr)
library(scCATCH)
library(biomaRt)
library(scater)
library(scran)
library(batchelor)
library(DelayedMatrixStats)
library(SC3)
theme_set(theme_bw())
```


# Obtain files

## Download data

This project uses the data from [Grosselin et al, 2019](https://pubmed.ncbi.nlm.nih.gov/31152164/9), which is uploaded to GEO.

```{bash, eval=FALSE}
mkdir -p data
cd data
wget -r -np -nd 'https://ftp.ncbi.nlm.nih.gov/geo/series/GSE117nnn/GSE117309/suppl/GSE117309_RAW.tar' -R "index.html*" # Omitting the index file
```

# Read files into R

```{r}
# Get a list of all files that match the patternt
ChIP_files <- list.files(path="data/",pattern=".txt", full.names = T) 

# Remove the jurkat and Ramos files so that they are not loaded because they are not relevant to the study
scChIP_hg38 <- ChIP_files[!grepl('Jurkat|Ramos|mm10',ChIP_files)]

# Read all files into a list of dataframes
scChIP_hg38 <- mapply(read.table, scChIP_hg38, MoreArgs = list(header=T, row.names=1))

# Clean-up object names for readability
names(scChIP_hg38) <- names(scChIP_hg38) %>% str_remove(".txt.gz") %>% gsub("data/GSM32908.._CountTable_","",.)
```

We will read files as `SingleCellExperiment` objects:

```{r}
scChIP_hg38 <- sapply(scChIP_hg38, function(x) {SingleCellExperiment(assays=list(counts=x))})
```

# Quality control

First, we will do some exploratory graphs:

```{r, fig.width=10, fig.height=8}
df_QC_per_cell <- data.frame()
df_QC_per_window <- data.frame()

plot_QC <- function(scChIP_list){
  for (df in 1:length(scChIP_list)){
  df_ChIP <- assay(scChIP_list[[df]],"counts")  
  df_QC_per_cell_temp <- data.frame(matrix(ncol = 4, nrow =  ncol(df_ChIP)))
  colnames(df_QC_per_cell_temp) <- c("cell","type","counts_per_cell","windows_per_cell")
  df_QC_per_cell_temp$cell <- colnames(df_ChIP)
  df_QC_per_cell_temp$type <- names(scChIP_list)[df]
  df_QC_per_cell_temp$type <- str_remove_all(df_QC_per_cell_temp$type, "_scChIP_H3K27me3")
  df_QC_per_cell_temp$counts_per_cell <- colSums(df_ChIP)
  df_QC_per_cell_temp$windows_per_cell <- colSums(df_ChIP!=0)
  df_QC_per_cell <- rbind(df_QC_per_cell_temp,df_QC_per_cell)
  
  df_QC_per_window_temp <- data.frame(matrix(ncol = 4, nrow =  nrow(df_ChIP)))
  colnames(df_QC_per_window_temp) <- c("window","type","counts_per_window","cells_per_window")
  df_QC_per_window_temp$window <- rownames(df_ChIP)
  df_QC_per_window_temp$type <- names(scChIP_list)[df]
  df_QC_per_window_temp$type <- str_remove_all(df_QC_per_window_temp$type, "_scChIP_H3K27me3")
  df_QC_per_window_temp$counts_per_window <- rowSums(df_ChIP)
  df_QC_per_window_temp$cells_per_window <-rowSums(df_ChIP!=0)
  df_QC_per_window <- rbind(df_QC_per_window_temp,df_QC_per_window)
  }
return(list(df_QC_per_cell, df_QC_per_window))
}

QC_scChIP_hg38 <- plot_QC(scChIP_hg38)


p1 <- ggplot(QC_scChIP_hg38[[1]], aes(x=type, y=log(counts_per_cell+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total counts per cell") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())


p2 <- ggplot(QC_scChIP_hg38[[1]], aes(x=type, y=log(windows_per_cell+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total windows profiled per cell") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())

p3 <- ggplot(QC_scChIP_hg38[[2]], aes(x=type, y=log(counts_per_window+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total counts per window") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())


p4 <- ggplot(QC_scChIP_hg38[[2]], aes(x=type, y=log(cells_per_window+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total cells profiled per window") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())

ggarrange(p1, p2, p3, p4, common.legend=T, legend="right")
```



# QC filtering

Based on these grpahs, we will remove windows with 0 reads in more than 1% cells, and cells with less than 1000 counts or above the upper percentile :

```{r}
rm_QC <- function(scChip_df){
  #scChip_df_filtered <- scChip_df
  # scChip_df <- assay(scChip_df,"counts")
  # Removing poorly covered regions
  min_counts <- ncol(scChip_df)*0.01
  window_filter <- rowSums(counts(scChip_df)!=0) > min_counts 
  
  # Removing low quality cells
  max_percentile <- quantile(colSums(counts(scChip_df)), probs=seq(0, 1, 0.01))
  cell_filter <- (colSums(counts(scChip_df)) > 1000) & (colSums(counts(scChip_df)) < max_percentile[95]) 

  scChip_df <- scChip_df[window_filter,cell_filter]
  return(scChip_df)
}

# We will only keep windows in all datasets for further integration 
scChIP_hg38 <- sapply(scChIP_hg38,rm_QC)
windows_hg38 <- Reduce(intersect, lapply(scChIP_hg38, rownames))
scChIP_hg38 <- lapply(scChIP_hg38, function(x) x[windows_hg38,])
```

# Count normalization

After QC filtering, the next step is to normalize counts across samples by dividing the number of counts by the total reads per cell and multiplying by the mean number of reads across all cells.

```{r}
norm_counts <- function(scChIP_df){
  scChIP_df_assay <- assay(scChIP_df,"counts")
  mean_reads_per_cell <- mean(colSums(scChIP_df_assay))
  scChIP_df_norm <- sweep(scChIP_df_assay,2, colSums(scChIP_df_assay),"/")
  scChIP_df_norm <- sweep(scChIP_df_norm,2, mean_reads_per_cell,"*")
  scChIP_df_norm <- as.data.frame(scChIP_df_norm)
  assay(scChIP_df, "norm_counts") <- scChIP_df_norm
  return(scChIP_df)
}

# Apply the function
scChIP_hg38 <- sapply(scChIP_hg38,norm_counts)
```

# Data integration

## Multibatch normalization

First we perform batch normalization to normalize between samples

```{r}
rescaled_hg38 <- multiBatchNorm(scChIP_hg38[[1]],
                                scChIP_hg38[[2]],
                                scChIP_hg38[[3]],
                                scChIP_hg38[[4]])


for (i in 1:4){
  scChIP_hg38[[i]] <- rescaled_hg38[[i]]
}

# Let's empty some space
rm(rescaled_hg38)
```

## Feature selection

We will select the 5000 most informative (variable) windows in all datasets

```{r}
geneVar_ChIP <- list()

for (i in 1:length(scChIP_hg38)){
  geneVar_ChIP[[i]] <- modelGeneVar(scChIP_hg38[[i]])@metadata[["var"]]
}

geneVar_ChIP <- do.call(cbind, geneVar_ChIP) %>% as.data.frame() %>%  mutate(mean_var=rowMeans(.))

relevant_features_hg38 <- slice_max(geneVar_ChIP, order_by=mean_var,n=5000) %>% rownames()
```

## Dataset combination

```{r}
counts_hg38 <- do.call(cbind, lapply(scChIP_hg38, counts))
logcounts_hg38 <- do.call(cbind, lapply(scChIP_hg38, logcounts))

combined_hg38 <- SingleCellExperiment( 
    assays = list(counts = counts_hg38, logcounts = logcounts_hg38)) 

# Empty space
rm(counts_hg38)
rm(logcounts_hg38)
```

## MNN integration

```{r}
# Human
combined_hg38$model <- (str_split(colnames(combined_hg38), "\\.", simplify=T)[,1])

mnn_out <- fastMNN(
  combined_hg38[relevant_features_hg38, combined_hg38$model == "HBCx-95_scChIP_H3K27me3_hg38"],
  combined_hg38[relevant_features_hg38, combined_hg38$model == "HBCx-95-CapaR_scChIP_H3K27me3_hg38"],
  combined_hg38[relevant_features_hg38, combined_hg38$model == "HBCx-22_scChIP_H3K27me3_hg38"],
  combined_hg38[relevant_features_hg38, combined_hg38$model == "HBCx-22-TamR_scChIP_H3K27me3_hg38"],
  k = 20, d = 50, 
  BNPARAM = BiocNeighbors::AnnoyParam())

reducedDim(combined_hg38, "MNN") <- reducedDim(mnn_out, "corrected")

plotReducedDim(combined_hg38, dimred = "MNN", colour_by="model") +
    ggtitle("MNN Ouput Reduced Dimensions - hg38") +
  scale_colour_hue(name="Model",labels=c("HBCx-22-TamR_hg38",
                               "HBCx-22_hg38",
                               "HBCx-95-CapaR_hg38",
                               "HBCx-95_hg38")) +
  theme(plot.title=element_text(hjust=0.5))
# Clear up space
rm(mnn_out)
```


# Dimensionality reduction

```{r}
metadata(combined_hg38)$relevant_features <- relevant_features_hg38
combined_hg38 <- runPCA(combined_hg38, ncomponents = 30,
             subset_row = metadata(combined_hg38)$relevant_features)
combined_hg38 <- runUMAP(combined_hg38,
              n_neighbors = 15,
              subset_row = metadata(combined_hg38)$relevant_features)

gPCA_hg38 <- plotReducedDim(combined_hg38, "PCA", colour_by = "model")
gUMAP_hg38 <- plotReducedDim(combined_hg38, "UMAP", colour_by = "model") 
patchwork::wrap_plots(gPCA_hg38, gUMAP_hg38, heights = 1, widths = 1, ncol = 1)
```

# Consensus clustering

```{r, fig.width=7, fig.height=7}
# We will add an extra column required by SC3

rowData(combined_hg38)$feature_symbol <- rownames(combined_hg38) 

## SC3 will return an SCE object with appended "sc3_" columns
sce <- sc3(combined_hg38[metadata(combined_hg38)$relevant_features, ],
          ks = 3:6,
          k_estimator = TRUE, biology=T) # biology=T for differential expression

g3 <- plotReducedDim(sce, dimred = "MNN", colour_by = "sc3_3_clusters")
g4 <- plotReducedDim(sce, dimred = "MNN", colour_by = "sc3_4_clusters")
g5 <- plotReducedDim(sce, dimred = "MNN", colour_by = "sc3_5_clusters")
g6 <- plotReducedDim(sce, dimred = "MNN", colour_by = "sc3_6_clusters")
patchwork::wrap_plots(g3, g4, g5, g6, widths = 1, heights = 1, ncol = 1)

g3 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "sc3_3_clusters")
g4 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "sc3_4_clusters")
g5 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "sc3_5_clusters")
g6 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "sc3_6_clusters")
patchwork::wrap_plots(g3, g4, g5, g6, widths = 1, heights = 1, ncol = 2)
```

# Cluster annotation and functional analysis

# Session info

```{r}
sessionInfo()
```

