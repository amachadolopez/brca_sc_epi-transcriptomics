---
title: "sc-ChIPseq analysis of breast cancer"
author: "Alba Machado-Lopez"
date: "November 2022"
output: html_document
knit: (function(input_file, encoding) {
    out_dir <- 'docs';
    rmarkdown::render(input_file,
      encoding=encoding,
      output_file=file.path(dirname(input_file), out_dir, 'brca_sc_epigenomics_mm10.html'))})
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries

```{r, message=F}
library(dplyr)
library(stringr)
library(R.utils)
library(ggplot2)
library(ggpubr)
library(SingleCellExperiment)
library(Seurat)
library(purrr)
library(scCATCH)
library(biomaRt)
library(SingleCellExperiment)
library(scater)
library(scran)
library(batchelor)
library(DelayedMatrixStats)
library(SC3)


theme_set(theme_bw())
```


# Obtain files

## Download data

This project uses the data from [Grosselin et al, 2019](https://pubmed.ncbi.nlm.nih.gov/31152164/9), which is uploaded to GEO.

```{bash, eval=FALSE}
mkdir -p data
cd data
wget -r -np -nd 'https://ftp.ncbi.nlm.nih.gov/geo/series/GSE117nnn/GSE117309/suppl/GSE117309_RAW.tar' -R "index.html*" # Omitting the index file
```

# Read files into R

```{r}
# Get a list of all files that match the patternt
ChIP_files <- list.files(path="data/",pattern=".txt", full.names = T) 

# Remove the jurkat and Ramos files so that they are not loaded because they are not relevant to the study
scChIP_mm10 <- ChIP_files[!grepl('Jurkat|Ramos|hg38',ChIP_files)]

# Read all files into a list of dataframes
scChIP_mm10 <- mapply(read.table, scChIP_mm10, MoreArgs = list(header=T, row.names=1))

# Clean-up object names for readability
names(scChIP_mm10) <- names(scChIP_mm10) %>% str_remove(".txt.gz") %>% gsub("data/GSM32908.._CountTable_","",.)
```

We will read files as `SingleCellExperiment` objects, one for human and another for mouse cells.

```{r}
scChIP_mm10 <- sapply(scChIP_mm10, function(x) {SingleCellExperiment(assays=list(counts=x))})
```

# Quality control

First, we will do some exploratory graphs:

```{r,, fig.width=10, fig.height=8}
df_QC_per_cell <- data.frame()
df_QC_per_window <- data.frame()

plot_QC <- function(scChIP_list){
  for (df in 1:length(scChIP_list)){
  df_ChIP <- assay(scChIP_list[[df]],"counts")  
  df_QC_per_cell_temp <- data.frame(matrix(ncol = 4, nrow =  ncol(df_ChIP)))
  colnames(df_QC_per_cell_temp) <- c("cell","type","counts_per_cell","windows_per_cell")
  df_QC_per_cell_temp$cell <- colnames(df_ChIP)
  df_QC_per_cell_temp$type <- names(scChIP_list)[df]
  df_QC_per_cell_temp$type <- str_remove_all(df_QC_per_cell_temp$type, "_scChIP_H3K27me3")
  df_QC_per_cell_temp$counts_per_cell <- colSums(df_ChIP)
  df_QC_per_cell_temp$windows_per_cell <- colSums(df_ChIP!=0)
  df_QC_per_cell <- rbind(df_QC_per_cell_temp,df_QC_per_cell)
  
  df_QC_per_window_temp <- data.frame(matrix(ncol = 4, nrow =  nrow(df_ChIP)))
  colnames(df_QC_per_window_temp) <- c("window","type","counts_per_window","cells_per_window")
  df_QC_per_window_temp$window <- rownames(df_ChIP)
  df_QC_per_window_temp$type <- names(scChIP_list)[df]
  df_QC_per_window_temp$type <- str_remove_all(df_QC_per_window_temp$type, "_scChIP_H3K27me3")
  df_QC_per_window_temp$counts_per_window <- rowSums(df_ChIP)
  df_QC_per_window_temp$cells_per_window <-rowSums(df_ChIP!=0)
  df_QC_per_window <- rbind(df_QC_per_window_temp,df_QC_per_window)
  }
return(list(df_QC_per_cell, df_QC_per_window))
}

QC_scChIP_mm10 <- plot_QC(scChIP_mm10)


p1 <- ggplot(QC_scChIP_mm10[[1]], aes(x=type, y=log(counts_per_cell+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total counts per cell") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())


p2 <- ggplot(QC_scChIP_mm10[[1]], aes(x=type, y=log(windows_per_cell+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total windows profiled per cell") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())

p3 <- ggplot(QC_scChIP_mm10[[2]], aes(x=type, y=log(counts_per_window+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total counts per window") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())


p4 <- ggplot(QC_scChIP_mm10[[2]], aes(x=type, y=log(cells_per_window+0.01), fill=type)) + 
  geom_violin() + 
  ggtitle("Total cells profiled per window") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank())

ggarrange(p1, p2, p3, p4, common.legend=T, legend="right")
```



# QC filtering

Based on these grpahs, we will remove windows with 0 reads in more than 1% cells, and cells with less than 1000 counts or above the upper percentile :

```{r}
rm_QC <- function(scChip_df){
  #scChip_df_filtered <- scChip_df
  # scChip_df <- assay(scChip_df,"counts")
  # Removing poorly covered regions
  min_counts <- ncol(scChip_df)*0.01
  window_filter <- rowSums(counts(scChip_df)!=0) > min_counts 
  
  # Removing low quality cells
  max_percentile <- quantile(colSums(counts(scChip_df)), probs=seq(0, 1, 0.01))
  cell_filter <- (colSums(counts(scChip_df)) > 1000) & (colSums(counts(scChip_df)) < max_percentile[95]) 

  scChip_df <- scChip_df[window_filter,cell_filter]
  return(scChip_df)
}

# We will only keep windows in all datasets for further integration 
scChIP_mm10 <- sapply(scChIP_mm10,rm_QC)
windows_mm10 <- Reduce(intersect, lapply(scChIP_mm10, rownames))
scChIP_mm10 <- lapply(scChIP_mm10, function(x) x[windows_mm10,])
```

# Count normalization

After QC filtering, the next step is to normalize counts across samples by dividing the number of counts by the total reads per cell and multiplying by the mean number of reads across all cells.

```{r}
norm_counts <- function(scChIP_df){
  scChIP_df_assay <- assay(scChIP_df,"counts")
  mean_reads_per_cell <- mean(colSums(scChIP_df_assay))
  scChIP_df_norm <- sweep(scChIP_df_assay,2, colSums(scChIP_df_assay),"/")
  scChIP_df_norm <- sweep(scChIP_df_norm,2, mean_reads_per_cell,"*")
  scChIP_df_norm <- as.data.frame(scChIP_df_norm)
  assay(scChIP_df, "norm_counts") <- scChIP_df_norm
  return(scChIP_df)
}

# Mouse and human cells are normalized separately
scChIP_mm10 <- sapply(scChIP_mm10,norm_counts)
```

# Data integration

## Multibatch normalization

First we perform batch normalization to normalize between samples

```{r}
rescaled_mm10 <- multiBatchNorm(scChIP_mm10[[1]],
                                scChIP_mm10[[2]],
                                scChIP_mm10[[3]],
                                scChIP_mm10[[4]])

for (i in 1:4){
  scChIP_mm10[[i]] <- rescaled_mm10[[i]]
}

# Let's empty some space
rm(rescaled_mm10)
```

## Feature selection

We will select the 5000 most informative (variable) windows in all datasets

```{r}
geneVar_ChIP_mm10 <- list()

for (i in 1:length(scChIP_mm10)){
  geneVar_ChIP_mm10[[i]] <- modelGeneVar(scChIP_mm10[[i]])@metadata[["var"]]
}

geneVar_ChIP_mm10 <- do.call(cbind, geneVar_ChIP_mm10) %>% as.data.frame() %>%  mutate(mean_var=rowMeans(.))
2
relevant_features_mm10 <- slice_max(geneVar_ChIP_mm10, order_by=mean_var,n=5000) %>% rownames()
```

## Dataset combination

```{r}


counts_mm10 <- do.call(cbind, lapply(scChIP_mm10, counts))
logcounts_mm10 <- do.call(cbind, lapply(scChIP_mm10, logcounts))

combined_mm10 <- sce <- SingleCellExperiment( 
    assays = list(counts = counts_mm10, logcounts = logcounts_mm10)) 

# Empty space
rm(counts_mm10)
rm(logcounts_mm10)
```

## MNN integration

```{r}
# Mouse
combined_mm10$model <- (str_split(colnames(combined_mm10), "\\.", simplify=T)[,1])

mnn_out_mm10 <- fastMNN(
  combined_mm10[relevant_features_mm10, combined_mm10$model == "HBCx-95_scChIP_H3K27me3_mm10"],
  combined_mm10[relevant_features_mm10, combined_mm10$model == "HBCx-95-CapaR_scChIP_H3K27me3_mm10"],
  combined_mm10[relevant_features_mm10, combined_mm10$model == "HBCx-22_scChIP_H3K27me3_mm10"],
  combined_mm10[relevant_features_mm10, combined_mm10$model == "HBCx-22-TamR_scChIP_H3K27me3_mm10"],
  k = 20, d = 50, 
  BNPARAM = BiocNeighbors::AnnoyParam())

reducedDim(combined_mm10, "MNN") <- reducedDim(mnn_out_mm10, "corrected")

plotReducedDim(combined_mm10, dimred = "MNN", colour_by="model") +
    ggtitle("MNN Ouput Reduced Dimensions - mm10") +
  scale_colour_hue(name="Model",labels=c("HBCx-22-TamR_mm10",
                               "HBCx-22_mm10",
                               "HBCx-95-CapaR_mm10",
                               "HBCx-95_mm10")) +
  theme(plot.title=element_text(hjust=0.5))


# Again, empty some space 
rm(mnn_out_mm10)
```


# Dimensionality reduction

```{r}
metadata(combined_mm10)$relevant_features <- relevant_features_mm10
combined_mm10 <- runPCA(combined_mm10, ncomponents = 30,
             subset_row = metadata(combined_mm10)$relevant_features)
combined_mm10 <- runUMAP(combined_mm10,
              n_neighbors = 15,
              subset_row = metadata(combined_mm10)$relevant_features)

gPCA_mm10 <- plotReducedDim(combined_mm10, "PCA", colour_by = "model")
gUMAP_mm10 <- plotReducedDim(combined_mm10, "UMAP", colour_by = "model")
patchwork::wrap_plots(gPCA_mm10, gUMAP_mm10, heights = 1, widths = 1, ncol = 1)

```

# Consensus clustering


```{r, fig.width=7, fig.height=7}
# We will add an extra column required by SC3
rowData(combined_mm10)$feature_symbol <- rownames(combined_mm10) 

## SC3 will return an SCE object with appended "sc3_" columns
sce_mm10 <- sc3(combined_mm10[metadata(combined_mm10)$relevant_features, ],
          ks = 3:6,
          k_estimator = TRUE, biology=T)

g3_mm10 <- plotReducedDim(sce_mm10, dimred = "MNN", colour_by = "sc3_3_clusters")
g4_mm10 <- plotReducedDim(sce_mm10, dimred = "MNN", colour_by = "sc3_4_clusters")
g5_mm10 <- plotReducedDim(sce_mm10, dimred = "MNN", colour_by = "sc3_5_clusters")
g6_mm10 <- plotReducedDim(sce_mm10, dimred = "MNN", colour_by = "sc3_6_clusters")
patchwork::wrap_plots(g3_mm10, g4_mm10, g5_mm10, g6_mm10, widths = 1, heights = 1, ncol = 1)

g3 <- plotReducedDim(sce_mm10, dimred = "UMAP", colour_by = "sc3_3_clusters")
g4 <- plotReducedDim(sce_mm10, dimred = "UMAP", colour_by = "sc3_4_clusters")
g5 <- plotReducedDim(sce_mm10, dimred = "UMAP", colour_by = "sc3_5_clusters")
g6 <- plotReducedDim(sce_mm10, dimred = "UMAP", colour_by = "sc3_6_clusters")
patchwork::wrap_plots(g3, g4, g5, g6, widths = 1, heights = 1, ncol = 2)
```


# Session info

```{r}
sessionInfo()
```

